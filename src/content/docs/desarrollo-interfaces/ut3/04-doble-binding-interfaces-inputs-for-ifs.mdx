---
title: "04. Data Binding, Interfaces, Inputs y Control de Flujo en Angular"
description: "Profundiza en la interactividad de Angular: explora el doble binding, define estructuras con interfaces, comunica componentes con Inputs y controla la renderización con @for y @if."
draft: true
---

En esta unidad, vamos a explorar algunos de los mecanismos más potentes de Angular para construir interfaces dinámicas e interactivas. Entenderemos cómo los datos fluyen entre los componentes y la vista (Data Binding), cómo definir estructuras de datos claras con Interfaces, cómo los componentes se comunican entre sí a través de `Inputs`, y cómo controlar la renderización condicional y repetitiva de elementos con los nuevos bloques `@for` y `@if`.

---

## 1. El Doble Binding (Two-Way Data Binding) en Angular

El **Doble Binding** en Angular es una característica poderosa que simplifica la sincronización de datos entre el modelo (la lógica del componente) y la vista (el template HTML). Esto significa que si el valor en el modelo cambia, la vista se actualiza automáticamente, y si el valor en la vista cambia (por ejemplo, por la interacción del usuario en un campo de entrada), el modelo se actualiza automáticamente.

Angular logra esto combinando **Property Binding** (del componente a la vista) y **Event Binding** (de la vista al componente).

El doble binding se implementa comúnmente usando la directiva `ngModel` dentro de un formulario HTML, encapsulada en la sintaxis de "banana in a box" `[()]`.

```html
<!-- En tu componente HTML -->
<input [(ngModel)]="nombreUsuario" placeholder="Introduce tu nombre">
<p>Hola, {{ nombreUsuario }}!</p>
```

```typescript
// En tu componente TypeScript
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms'; // Necesario para ngModel

@Component({
  selector: 'app-mi-componente',
  standalone: true,
  imports: [FormsModule],
  template: `
    <input [(ngModel)]="nombreUsuario" placeholder="Introduce tu nombre">
    <p>Hola, {{ nombreUsuario }}!</p>
  `,
  styleUrls: ['./mi-componente.component.css']
})
export class MiComponente {
  nombreUsuario: string = '';
}
```

-   Cuando el usuario escribe en el `input`, `nombreUsuario` en el componente se actualiza.
-   Si `nombreUsuario` se cambia programáticamente en el componente, el `input` y el párrafo se actualizan.

:::note[Importante para `ngModel`]

Para usar `[(ngModel)]`, debes importar `FormsModule` en tu componente o en el módulo donde lo estés utilizando si no es un componente `standalone`.

:::

---

## 2. Creación de Interfaces para Estructurar Datos

En Angular, que se basa en TypeScript, las **interfaces** son esenciales para definir la forma de los objetos. Proporcionan una manera de asegurar que tus datos siguen una estructura consistente, mejorando la legibilidad del código, facilitando la colaboración y permitiendo a TypeScript realizar comprobaciones de tipo en tiempo de compilación. Esto es especialmente útil cuando trabajas con datos que provienen de APIs o cuando defines las propiedades esperadas de tus componentes.

Para crear una interfaz, puedes usar Angular CLI:

```bash
ng generate interface nombre-de-la-interfaz
# O de forma abreviada
ng g i nombre-de-la-interfaz
```

Por ejemplo, si necesitas una interfaz para representar la información de una ubicación, puedes ejecutar:

```bash
ng generate interface HousingLocation
```

Esto creará un archivo `src/app/housing-location.ts` (o similar) con el siguiente contenido inicial:

```typescript
export interface HousingLocation {
  // Define las propiedades aquí
}
```

Luego, puedes definir las propiedades de tu interfaz:

```typescript
// src/app/housing-location.ts
export interface HousingLocation {
  id: number;
  name: string;
  city: string;
  state: string;
  photo: string;
  availableUnits: number;
  wifi: boolean;
  laundry: boolean;
}
```

Ahora, puedes usar `HousingLocation` como un tipo para las propiedades de tus componentes o los parámetros de tus funciones, asegurando que los datos siempre cumplan con esta estructura.

---

## 3. Comunicación Entre Componentes con `@Input()`

Los componentes en Angular a menudo necesitan comunicarse entre sí. Cuando un componente "padre" quiere pasar datos a un componente "hijo", utilizamos la directiva **`@Input()`**. Esto permite que el componente hijo reciba valores de sus propiedades de un componente padre que lo esté utilizando.

### Añadir Inputs en Componentes Hijo

En el componente hijo, debes importar `Input` (o `input` a partir de Angular 16+) desde `@angular/core` y decorar la propiedad que recibirá los datos con `@Input()`.

**Con `@Input()` (para versiones antiguas o si prefieres el decorador):**

```typescript
// src/app/housing-location/housing-location.component.ts
import { Component, Input } from '@angular/core';
import { HousingLocation } from '../housing-location'; // Importa la interfaz

@Component({
  selector: 'app-housing-location',
  standalone: true,
  templateUrl: './housing-location.component.html',
  styleUrls: ['./housing-location.component.css']
})
export class HousingLocationComponent {
  @Input() housingLocation!: HousingLocation;
}
```

**Utilizando `input()` (nuevo API a partir de Angular 16+ para standalone components):**

```typescript
// src/app/housing-location/housing-location.component.ts
import { Component, input } from '@angular/core';
import { HousingLocation } from '../housing-location'; // Importa la interfaz

@Component({
  selector: 'app-housing-location',
  standalone: true,
  templateUrl: './housing-location.component.html',
  styleUrls: ['./housing-location.component.css']
})
export class HousingLocationComponent {
  // Si el input es requerido, se usa input.required<Tipo>()
  housingLocation = input.required<HousingLocation>();

  // Si el input es opcional y puede tener un valor por defecto:
  // guestName = input<string>('Invitado');
}
```

### Passing Data from Parent Component (Property Binding)

Desde el componente padre, pasas los datos al componente hijo utilizando el **Property Binding** (enlaces de propiedades). Esto se hace encerrando la propiedad del hijo entre corchetes `[]` y asignándole una propiedad del componente padre.

```html
<!-- En el template del componente padre (e.g., app.component.html) -->
<section class="results">
  <!-- Suponiendo que 'home' es una propiedad en el componente padre con tipo HousingLocation -->
  <app-housing-location [housingLocation]="home"></app-housing-location>
</section>
```

En este ejemplo, el componente padre tiene una propiedad `home` (de tipo `HousingLocation`) y la está pasando al `housingLocation` `@Input()` del componente `app-housing-location`.

### Mostrar Valores de Propiedades Bindeadas en el Hijo

Una vez que el componente hijo recibe los datos a través de `@Input()`, puede acceder a ellos directamente en su plantilla HTML.

**Para `@Input()`:**

```html
<!-- src/app/housing-location/housing-location.component.html -->
<section class="listing">
  <img
    class="listing-photo"
    [src]="housingLocation.photo"
    alt="Exterior photo of {{ housingLocation.name }}"
    crossorigin
  />
  <h2 class="listing-heading">{{ housingLocation.name }}</h2>
  <p class="listing-location">{{ housingLocation.city }}, {{ housingLocation.state }}</p>
</section>
```

**Para `input()` (nuevo API):**

Observa que con el nuevo `input()` API, necesitas llamar al input como una función `housingLocation()` para acceder a su valor.

```html
<!-- src/app/housing-location/housing-location.component.html -->
<section class="listing">
  <img
    class="listing-photo"
    [src]="housingLocation().photo"
    alt="Exterior photo of {{ housingLocation().name }}"
    crossorigin
  />
  <h2 class="listing-heading">{{ housingLocation().name }}</h2>
  <p class="listing-location">{{ housingLocation().city }}, {{ housingLocation().state }}</p>
</section>
```

---

## 4. Control de Flujo con `@for` y `@if`

Angular 17+ introdujo una sintaxis de **control de flujo declarativa** con bloques `{}` integrados en las plantillas, lo que mejora la legibilidad y el rendimiento al reemplazar directivas estructurales como `*ngFor` y `*ngIf`. Estos bloques no requieren importar módulos adicionales como `CommonModule` en componentes `standalone`.

### Bloque `@for` para Listas

El bloque `@for` se utiliza para iterar sobre colecciones de datos y renderizar un template para cada elemento. Es más potente y ergonómico que el antiguo `*ngFor`.

**Sintaxis básica:**

```html
<ul>
  @for (item of items; track item.id) {
    <li>{{ item.name }}</li>
  }
</ul>
```

-   `item of items`: Itera sobre la colección `items`.
-   `track item.id`: Es **obligatorio** y crucial para el rendimiento. Angular utiliza esta función para identificar unívocamente cada elemento en la lista, lo que le permite optimizar actualizaciones (solo renderiza los elementos que han cambiado, se han añadido o eliminado).

**Con índices:**

Puedes acceder al índice de cada elemento usando la variable `$index`:

```html
<ul>
  @for (item of items; track item.id; let i = $index) {
    <li>{{ i + 1 }}. {{ item.name }}</li>
  }
</ul>
```

**Con `@empty`:**

El bloque `@empty` se renderiza cuando la colección está vacía. Es una alternativa elegante a una condición `*ngIf` separada.

```html
<ul>
  @for (item of items; track item.id) {
    <li>{{ item.name }}</li>
  } @empty {
    <li>No hay elementos para mostrar.</li>
  }
</ul>
```

### Bloque `@if` para Renderizado Condicional

El bloque `@if` se utiliza para renderizar condicionalmente un bloque de contenido. Es la alternativa a `*ngIf`.

**Sintaxis básica:**

```html
@if (isAdmin) {
  <button>Administrar usuarios</button>
}
```

**Con `@else`:**

Puedes proporcionar un bloque `@else` para renderizar contenido alternativo cuando la condición es falsa.

```html
@if (isLoggedIn) {
  <p>Bienvenido, {{ userName }}!</p>
} @else {
  <button>Iniciar Sesión</button>
}
```

**Con `@else if` (múltiples condiciones):**

También puedes encadenar condiciones con `@else if` para escenarios más complejos.

```html
@if (user.role === 'admin') {
  <p>Panel de Administración</p>
} @else if (user.role === 'editor') {
  <p>Panel de Edición</p>
} @else {
  <p>Panel de Usuario Estándar</p>
}
```

Estos bloques de control de flujo hacen que las plantillas de Angular sean más intuitivas, potentes y eficientes, alineándose con las mejores prácticas del desarrollo frontend moderno.

---
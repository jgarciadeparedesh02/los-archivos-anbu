---
title: "Práctica 3: Modelado de Datos para IoT con Cassandra"
description: "Diseña un modelo de datos en Cassandra para almacenar y consultar eficientemente series temporales de datos de sensores."
draft: true
---

## Escenario

Trabajas para "AgroSmart", una empresa que instala redes de sensores en campos de cultivo para monitorizar las condiciones ambientales. Tu tarea es diseñar la tabla en **Cassandra** para almacenar los datos de series temporales que envían estos sensores. La eficiencia en la escritura y, sobre todo, en la lectura de los datos es crucial.

El principio fundamental del modelado en Cassandra es: **diseñar tus tablas en función de las consultas que vas a realizar**.

--- 

## Parte 1: Análisis de las Consultas (Query-First Design)

El equipo de análisis de datos necesita realizar las siguientes consultas con mucha frecuencia:

1.  **Q1**: Obtener todas las mediciones de un sensor específico en un rango de tiempo determinado (ej: todas las lecturas del sensor `A-101` durante el mes de agosto de 2024).
2.  **Q2**: Obtener la última medición registrada para un sensor específico.
3.  **Q3**: Obtener todas las mediciones de todos los sensores de una zona geográfica (`sector`) en un día concreto.

--- 

## Parte 2: Diseño de la Tabla

Basándote en las consultas anteriores, tienes que diseñar el `CREATE TABLE` en CQL (Cassandra Query Language). Recuerda que la elección de la **PRIMARY KEY** es lo más importante en Cassandra. La clave primaria se compone de la **PARTITION KEY** (determina en qué nodo se almacenan los datos) y las **CLUSTERING COLUMNS** (determinan el orden de los datos dentro de una partición).

Los datos que envía cada sensor son:
-   `id_sensor` (ej: "A-101")
-   `sector` (ej: "Norte-Huelva")
-   `timestamp` (la fecha y hora de la medición)
-   `temperatura` (ej: 25.5)
-   `humedad` (ej: 85.2)
-   `nutrientes` (ej: 1.5)

**Instrucción**: Escribe la sentencia `CREATE TABLE mediciones_sensores`.

*Pistas para la PRIMARY KEY:*
-   Para **Q1** y **Q2**, necesitas agrupar todas las mediciones de un mismo sensor juntas. Esto sugiere que `id_sensor` debería ser parte de la clave de partición.
-   Para que los datos de un mismo sensor estén ordenados cronológicamente, `timestamp` es un candidato ideal para ser una **columna de clustering**.
-   Para **Q3**, necesitas poder consultar por `sector` y por día. Podrías crear una segunda tabla o, para este ejercicio, vamos a optimizar para Q1 y Q2 que son las más críticas. Vamos a añadir un campo `fecha` (solo el día, ej: '2024-08-15') para ayudar a particionar mejor los datos y evitar particiones demasiado grandes. Una buena clave de partición podría ser `(id_sensor, fecha)`.

```cql
-- Tu sentencia CREATE TABLE aquí
CREATE TABLE mediciones_sensores (
    id_sensor text,
    fecha date,
    timestamp timestamp,
    temperatura float,
    humedad float,
    nutrientes float,
    
    -- Define tu PRIMARY KEY aquí
    PRIMARY KEY ((...), ...)
)
WITH CLUSTERING ORDER BY (timestamp DESC);
-- Ordenamos por timestamp descendente para que la última medición (Q2) sea la primera fila, haciendo la consulta súper eficiente.
```

--- 

## Parte 3: Escritura de Consultas CQL

Ahora, con tu tabla ya diseñada, escribe las consultas en CQL para las peticiones que definimos.

**1. Insertar una nueva medición.**

```cql
-- Tu consulta INSERT aquí

```

**2. Ejecutar Q1: Obtener todas las mediciones del sensor `A-101` del día 15 de agosto de 2024.**

```cql
-- Tu consulta SELECT para Q1 aquí

```

**3. Ejecutar Q2: Obtener la última medición registrada para el sensor `A-101` en el día 15 de agosto de 2024.**

*Pista: Gracias al `CLUSTERING ORDER BY`, solo necesitas pedir la primera fila.*

```cql
-- Tu consulta SELECT para Q2 aquí

```

**4. (Bonus) ¿Cómo resolverías Q3?**

*Instrucción*: Explica brevemente qué estrategia usarías para poder consultar eficientemente todas las mediciones de un `sector` en un día concreto. ¿Crearías otra tabla? ¿Usarías un índice secundario (sabiendo que no son muy recomendados para campos de alta cardinalidad)?

*Tu explicación aquí:*


## Instrucciones de Entrega

1.  Copia el contenido de esta página en un nuevo fichero Markdown en tu repositorio personal.
2.  Completa la sentencia `CREATE TABLE`, las consultas `INSERT` y `SELECT`, y la explicación del bonus.
3.  Sube el fichero a tu repositorio y comparte el enlace con el profesor.
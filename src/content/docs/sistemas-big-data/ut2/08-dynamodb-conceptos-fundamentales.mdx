---
title: "Guía Práctica de DynamoDB: Conceptos y Comandos"
description: "Una guía completa de Amazon DynamoDB que cubre desde los conceptos teóricos fundamentales hasta las operaciones prácticas con ejemplos de AWS CLI."
---

import { Card, CardGrid } from '@astrojs/starlight/components';

Amazon DynamoDB es una base de datos NoSQL de tipo clave-valor y documental, totalmente administrada y sin servidor (serverless), diseñada para ofrecer un rendimiento de milisegundos de un solo dígito a cualquier escala.

Esta guía combina la teoría esencial con ejemplos prácticos usando la **AWS Command Line Interface (CLI)**, que puedes ejecutar en tu terminal o directamente en la **AWS CloudShell**.

---

## Componentes Centrales de DynamoDB

<CardGrid>
  <Card title="Tablas" icon="table">
    El contenedor principal para tus datos. No tienen un esquema fijo, a excepción de la clave primaria.
  </Card>
  <Card title="Ítems" icon="document">
    Análogo a una fila o un documento. Es un conjunto de atributos identificado de forma única por su clave.
  </Card>
  <Card title="Atributos" icon="list">
    Los datos que componen un ítem, como `nombre` o `edad`. DynamoDB requiere que especifiques el tipo de dato (S para String, N para Number, etc.).
  </Card>
</CardGrid>

---

## 1. Diseño y Gestión de Tablas con AWS CLI

El primer paso es siempre diseñar y crear la tabla. La decisión más importante es la **clave primaria**, que determina qué consultas serán eficientes.

### Claves Primarias: La base de todo

-   **Clave Primaria Simple (Solo Clave de Partición):** Para búsquedas de tipo clave-valor. `(ej: user_id)`
-   **Clave Primaria Compuesta (Clave de Partición + Clave de Ordenación):** Para agrupar ítems y realizar consultas complejas sobre ese grupo. `(ej: customer_id + order_date)`

#### Ejemplo CLI: Creando tablas

1.  **Tabla `Users` con clave simple:**
    ```bash
    aws dynamodb create-table \
        --table-name Users \
        --attribute-definitions \
            AttributeName=user_id,AttributeType=S \
        --key-schema \
            AttributeName=user_id,KeyType=HASH \
        --billing-mode PAY_PER_REQUEST
    ```
    *   `--attribute-definitions`: Declara los atributos que se usarán en claves.
    *   `--key-schema`: Define la clave primaria. `HASH` es la clave de partición.
    *   `--billing-mode`: `PAY_PER_REQUEST` es el modo Bajo Demanda, ideal para empezar.

2.  **Tabla `Orders` con clave compuesta:**
    ```bash
    aws dynamodb create-table \
        --table-name Orders \
        --attribute-definitions \
            AttributeName=customer_id,AttributeType=S \
            AttributeName=order_date,AttributeType=S \
        --key-schema \
            AttributeName=customer_id,KeyType=HASH \
            AttributeName=order_date,KeyType=RANGE \
        --billing-mode PAY_PER_REQUEST
    ```
    *   `RANGE` se usa para definir la clave de ordenación.

### Operaciones a Nivel de Tabla

-   **Listar todas tus tablas:**
    ```bash
    aws dynamodb list-tables
    ```
-   **Describir una tabla para ver su estado, claves e índices:**
    ```bash
    aws dynamodb describe-table --table-name Orders
    ```
-   **Eliminar una tabla (¡acción irreversible!):**
    ```bash
    aws dynamodb delete-table --table-name Users
    ```

---

## 2. Operaciones con Datos (CRUD) con AWS CLI

Una vez creada la tabla, podemos manipular los ítems.

### `put-item`: Crear o Reemplazar un Ítem

Esta operación inserta un nuevo ítem. Si ya existe un ítem con la misma clave primaria, **lo reemplaza por completo**.

```bash
aws dynamodb put-item \
    --table-name Users \
    --item '{ 
        "user_id": {"S": "user123"},
        "name": {"S": "Ana"},
        "email": {"S": "ana@example.com"},
        "age": {"N": "30"}
      }'
```
:::note
Fíjate en la sintaxis del JSON: cada valor de atributo es un objeto que especifica su tipo (`S` para String, `N` para Number).
:::

### `get-item`: Leer un Ítem por su Clave

Recupera un único ítem de forma muy eficiente si conoces su clave primaria completa.

```bash
aws dynamodb get-item \
    --table-name Users \
    --key '{"user_id": {"S": "user123"}}'
```

### `update-item`: Modificar un Ítem Existente

Es la forma preferida de actualizar un ítem, ya que permite modificar atributos específicos sin tener que leer y reescribir el ítem entero.

**Ejemplo:** Añadir un nuevo atributo `country` y aumentar la edad (`age`) en 1.

```bash
aws dynamodb update-item \
    --table-name Users \
    --key '{"user_id": {"S": "user123"}}' \
    --update-expression "SET country = :c ADD age :val" \
    --expression-attribute-values '{ 
        ":c": {"S": "Spain"},
        ":val": {"N": "1"}
      }' \
    --return-values UPDATED_NEW
```
*   `--update-expression`: Define la acción a realizar. `SET` para añadir/modificar, `ADD` para incrementar números.
*   `--expression-attribute-values`: Define los valores de las variables usadas en la expresión.

### `delete-item`: Eliminar un Ítem

Borra un único ítem identificado por su clave primaria.

```bash
aws dynamodb delete-item \
    --table-name Users \
    --key '{"user_id": {"S": "user123"}}'
```

---

## 3. Lectura de Datos a Gran Escala: `Query` vs. `Scan`

Esta es la diferencia más crítica para el rendimiento y el coste en DynamoDB.

### `query`: La Búsqueda Eficiente

Usa la clave primaria para encontrar ítems. Es rápida y barata porque solo lee los datos que necesita. **Siempre debes intentar usar `query` en tus aplicaciones.**

**Ejemplo:** Buscar todos los pedidos del cliente `CUST001` en la tabla `Orders`.

```bash
aws dynamodb query \
    --table-name Orders \
    --key-condition-expression "customer_id = :cid" \
    --expression-attribute-values '{ 
        ":cid": {"S": "CUST001"}
      }'
```
*   `--key-condition-expression`: La condición **debe** incluir la clave de partición. Opcionalmente, puede tener condiciones sobre la clave de ordenación.

### `scan`: La Búsqueda de Fuerza Bruta

Lee **todos los ítems** de la tabla y luego, opcionalmente, filtra los resultados. Es lenta, cara y debe evitarse en aplicaciones a gran escala.

**Ejemplo:** Encontrar todos los pedidos con estado `Shipped`.

```bash
aws dynamodb scan \
    --table-name Orders \
    --filter-expression "#s = :status" \
    --expression-attribute-names '{"#s": "status"}' \
    --expression-attribute-values '{ ":status": {"S": "Shipped"}}'
```
*   `--filter-expression`: Se aplica **después** de leer cada ítem. Pagas por la lectura de toda la tabla, aunque el filtro devuelva pocos resultados.
*   `#s` es un alias para `status`, que es una palabra reservada en DynamoDB.

:::danger[¡Cuidado con Scan!]
La solución correcta para el `scan` anterior sería crear un **Índice Secundario Global (GSI)** en el atributo `status` y luego hacer un `query` sobre ese índice.
:::

---

## 4. Gestión de Capacidad y Costes

<CardGrid>
  <Card title="Modo Provisionado" icon="rocket">
    **Ideal para cargas predecibles.** Asignas y pagas por una capacidad fija de lectura (RCU) y escritura (WCU) por hora. Más barato si el tráfico es constante.
  </Card>
  <Card title="Modo Bajo Demanda (On-Demand)" icon="cash">
    **Ideal para cargas impredecibles.** Pagas por cada operación de lectura/escritura. No hay planificación, DynamoDB escala automáticamente. Más caro por solicitud, pero perfecto para tráfico esporádico o picos.
  </Card>
</CardGrid>

---

## 5. Casos de Uso Comunes

<CardGrid>
    <Card title="Plataformas de E-commerce" icon="shopping-cart">
        **Por qué funciona:** Latencia ultrabaja para carritos de la compra, perfiles de usuario y catálogos de productos, escalando sin problemas en eventos de alta demanda.
    </Card>
    <Card title="Aplicaciones de Gaming" icon="gamepad">
        **Por qué funciona:** Rendimiento masivo para tablas de clasificación, estado de jugadores e inventarios, soportando millones de usuarios simultáneos.
    </Card>
    <Card title="Gestión de Sesiones de Usuario" icon="user">
        **Por qué funciona:** Almacenamiento rápido de datos de sesión con la función **Time To Live (TTL)**, que elimina automáticamente los ítems caducados sin coste.
    </Card>
    <Card title="Análisis en Tiempo Real" icon="chart-bar">
        **Por qué funciona:** Ingesta masiva de datos de telemetría o logs, que pueden ser procesados en tiempo real con **DynamoDB Streams** y AWS Lambda.
    </Card>
</CardGrid>
